# -*- coding: utf8 -*-
from __future__ import unicode_literals

import sys

import pytest


WARNINGS_SUMMARY_HEADER = 'warnings summary'


@pytest.fixture(autouse=True)
def enable_warnings_plugin(monkeypatch):
    """
    Auto-use fixture for this module which enables the warnings plugin, because it is opt-in.
    """
    monkeypatch.setenv('PYTEST_ADDOPTS', '-p _pytest.warnings')


@pytest.fixture
def pyfile_with_warnings(testdir, request):
    """
    Create a test file which calls a function in a module which generates warnings.
    """
    testdir.syspathinsert()
    test_name = request.function.__name__
    module_name = test_name.lstrip('test_') + '_module'
    testdir.makepyfile(**{
        module_name: '''
            import warnings
            def foo():
                warnings.warn(PendingDeprecationWarning("functionality is pending deprecation"))
                warnings.warn(DeprecationWarning("functionality is deprecated"))
                return 1
        ''',
        test_name: '''
            import {module_name}
            def test_func():
                assert {module_name}.foo() == 1
        '''.format(module_name=module_name)
    })


def test_normal_flow(testdir, pyfile_with_warnings):
    """
    Check that the warnings section is displayed, containing test node ids followed by
    all warnings generated by that test node.
    """
    result = testdir.runpytest()
    result.stdout.fnmatch_lines([
        '*== %s ==*' % WARNINGS_SUMMARY_HEADER,

        '*test_normal_flow.py::test_func',

        '*normal_flow_module.py:3: PendingDeprecationWarning: functionality is pending deprecation',
        '*  warnings.warn(PendingDeprecationWarning("functionality is pending deprecation"))',

        '*normal_flow_module.py:4: DeprecationWarning: functionality is deprecated',
        '*  warnings.warn(DeprecationWarning("functionality is deprecated"))',
        '* 1 passed, 2 warnings*',
    ])
    assert result.stdout.str().count('test_normal_flow.py::test_func') == 1


def test_plugin_is_opt_in(testdir, pyfile_with_warnings, monkeypatch):
    """
    Ensure warnings plugin is opt-in (#2430).
    """
    monkeypatch.delenv('PYTEST_ADDOPTS')
    result = testdir.runpytest()
    assert WARNINGS_SUMMARY_HEADER not in result.stdout.str()
    assert 'DeprecationWarning' not in result.stdout.str()


def test_setup_teardown_warnings(testdir, pyfile_with_warnings):
    testdir.makepyfile('''
        import warnings
        import pytest

        @pytest.fixture
        def fix():
            warnings.warn(UserWarning("warning during setup"))
            yield
            warnings.warn(UserWarning("warning during teardown"))

        def test_func(fix):
            pass
    ''')
    result = testdir.runpytest()
    result.stdout.fnmatch_lines([
        '*== %s ==*' % WARNINGS_SUMMARY_HEADER,

        '*test_setup_teardown_warnings.py:6: UserWarning: warning during setup',
        '*warnings.warn(UserWarning("warning during setup"))',

        '*test_setup_teardown_warnings.py:8: UserWarning: warning during teardown',
        '*warnings.warn(UserWarning("warning during teardown"))',
        '* 1 passed, 2 warnings*',
    ])


@pytest.mark.parametrize('method', ['cmdline', 'ini'])
def test_as_errors(testdir, pyfile_with_warnings, method):
    args = ('-W', 'error') if method == 'cmdline' else ()
    if method == 'ini':
        testdir.makeini('''
            [pytest]
            filterwarnings= error
            ''')
    result = testdir.runpytest(*args)
    result.stdout.fnmatch_lines([
        'E       PendingDeprecationWarning: functionality is pending deprecation',
        'as_errors_module.py:3: PendingDeprecationWarning',
        '* 1 failed in *',
    ])


@pytest.mark.parametrize('method', ['cmdline', 'ini'])
def test_ignore(testdir, pyfile_with_warnings, method):
    args = ('-W', 'ignore') if method == 'cmdline' else ()
    if method == 'ini':
        testdir.makeini('''
        [pytest]
        filterwarnings= ignore
        ''')

    result = testdir.runpytest(*args)
    result.stdout.fnmatch_lines([
        '* 1 passed in *',
    ])
    assert WARNINGS_SUMMARY_HEADER not in result.stdout.str()



@pytest.mark.skipif(sys.version_info < (3, 0),
                    reason='warnings message is unicode is ok in python3')
def test_unicode(testdir, pyfile_with_warnings):
    testdir.makepyfile('''
        # -*- coding: utf8 -*-
        import warnings
        import pytest


        @pytest.fixture
        def fix():
            warnings.warn(u"测试")
            yield

        def test_func(fix):
            pass
    ''')
    result = testdir.runpytest()
    result.stdout.fnmatch_lines([
        '*== %s ==*' % WARNINGS_SUMMARY_HEADER,

        '*test_unicode.py:8: UserWarning: \u6d4b\u8bd5',
        '*warnings.warn(u"\u6d4b\u8bd5")',
        '* 1 passed, 1 warnings*',
    ])


@pytest.mark.skipif(sys.version_info >= (3, 0),
                    reason='warnings message is broken as it is not str instance')
def test_py2_unicode(testdir, pyfile_with_warnings):
    testdir.makepyfile('''
        # -*- coding: utf8 -*-
        import warnings
        import pytest


        @pytest.fixture
        def fix():
            warnings.warn(u"测试")
            yield

        def test_func(fix):
            pass
    ''')
    result = testdir.runpytest()
    result.stdout.fnmatch_lines([
        '*== %s ==*' % WARNINGS_SUMMARY_HEADER,

        '*test_py2_unicode.py:8: UserWarning: \u6d4b\u8bd5',
        '*warnings.warn(u"\u6d4b\u8bd5")',
        '*warnings.py:82: UnicodeWarning: This warning*\u6d4b\u8bd5',
        '* 1 passed, 2 warnings*',
    ])
