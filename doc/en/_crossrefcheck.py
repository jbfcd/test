from typing import Any
from typing import cast
from typing import List
from typing import NamedTuple
from typing import TYPE_CHECKING

import docutils.nodes
import sphinx.builders.dummy
import sphinx.transforms.post_transforms
import sphinx.util.logging
import sphinx.util.nodes


if TYPE_CHECKING:
    import sphinx.application

logger = sphinx.util.logging.getLogger(__name__)


class URIInfo(NamedTuple):
    uri: str
    document_name: str
    line_number: int


class LinkCollector(sphinx.transforms.post_transforms.SphinxPostTransform):
    """
    Traverse the document and collect all ``reference`` nodes that do not have the ``internal`` attribute set.

    Typically, they will look like this:

    .. code-block::

       <reference name="link text" refuri="https://uri">link text, maybe further styled</reference>

    We know those were not generated by Sphinx because they are missing the ``internal`` attribute.

    This transform doesn't actually modify the document tree, only collecting stuff.
    """

    builders = ("crossrefcheck",)
    default_priority = 900

    def run(self, **kwargs: Any) -> None:
        builder = cast(ExternalLinkChecker, self.app.builder)

        for refnode in self.document.traverse(docutils.nodes.reference):
            if "internal" in refnode or "refuri" not in refnode:
                continue
            uri = refnode["refuri"]
            lineno = sphinx.util.nodes.get_node_line(refnode)

            uri_info = URIInfo(uri, self.env.docname, lineno)
            builder.uris.append(uri_info)


class ExternalLinkChecker(sphinx.builders.dummy.DummyBuilder):
    """
    Custom builder that does not build anything, only analyzes the built result.

    It is invoked when the user selects ``crossrefcheck`` as builder name
    in the terminal:

    .. code-block:: sh

       $ sphinx-build -b crossrefcheck doc/en/ build

    For every link not generated by Sphinx, it compares whether it matches
    an inventory URL configured in ``intersphinx_mapping`` and warns if the
    link can be replaced by an cross-reference.

    .. note:: Special case: since we can't infer the hostname where our docs
       will be hosted, we provide a fake inventory configuration for ``pytest``
       explicitly in addition to the configured intersphinx inventories.

    .. note:: The matching is done by simply comparing URLs as strings
       via ``str.startswith``. This means that with ``"https://pluggy.readthedocs.io/en/stable"``
       configured in ``intersphinx_mapping``, no warning will be emitted for
       e.g. ``https://pluggy.readthedocs.io/en/latest`` or ``https://pluggy.readthedocs.io/de/stable``.
       If this is desired, reimplement the comparison by parsing hostnames
       via e.g. ``urllib.parse.urlparse`` etc.

    """

    name = "crossrefcheck"

    def __init__(self, app: "sphinx.application.Sphinx") -> None:
        super().__init__(app)
        self.uris: List[URIInfo] = []

    def finish(self) -> None:
        intersphinx_mapping = getattr(self.config, "intersphinx_mapping", dict())
        # add internal inventory as a fake intersphinx inventory too,
        # as we can't guess the pytest docs hostname otherwise.
        # This way, we treat hardcoded links that can be replaced
        # by internal references same as if we would crossref
        # to pytest docs via intersphinx.
        intersphinx_mapping["pytest"] = ("pytest", ("https://docs.pytest.org/", None))
        for uri_info in self.uris:
            for inventory, (_, (inventory_uri, *_)) in intersphinx_mapping.items():
                if uri_info.uri.startswith(inventory_uri):
                    location = (uri_info.document_name, uri_info.line_number)
                    if inventory == "pytest":
                        logger.warning(
                            "hardcoded link %r should be replaced by an internal reference",
                            uri_info.uri,
                            location=location,
                        )
                    else:
                        logger.warning(
                            "hardcoded link %r could be replaced by a cross-reference to %r inventory",
                            uri_info.uri,
                            inventory,
                            location=location,
                        )


def setup(app: "sphinx.application.Sphinx") -> None:
    """Register this extension."""
    app.add_builder(ExternalLinkChecker)
    app.add_post_transform(LinkCollector)
